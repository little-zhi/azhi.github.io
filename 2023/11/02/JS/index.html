

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>前端面试题   JS篇 - azhi</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1.数据类型基本数据类型：string、number、...">
  <meta name="author" content="John Doe">
  <link rel="icon" href="/images/icons/cz.png" type="image/png" sizes="16x16">
  
  
  
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">前端面试题   JS篇</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="">azhi</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">前端面试题   JS篇</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>November 02, 2023</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>19558</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h1><pre><code>基本数据类型：string、number、布尔、undefined、null BigInt 更精准的数  Symbol 处理对象重复的key
引用数据类型: 栈中存的是引用地址，值存在堆内存 object、array、function、RegExp、Date、Math  
堆是先进先出 - 栈是先进后出
</code></pre>
<h1 id="在js中，数据类型分为几类？它们的数据类型分别那有些？"><a href="#在js中，数据类型分为几类？它们的数据类型分别那有些？" class="headerlink" title="在js中，数据类型分为几类？它们的数据类型分别那有些？"></a>在js中，数据类型分为几类？它们的数据类型分别那有些？</h1><p>  基础数据类型：number，boolean，string，undefined，null<br>  (基础数据类型保存在栈内存中，操作的是值，改变原数据不会影响新变量)<br>  引用数据类型：object，array，function<br>  (引用数据类型保存在堆内存中，操作的是地址，改变其中一个另一个受影响)</p>
<h1 id="说说你对栈和堆的理解？"><a href="#说说你对栈和堆的理解？" class="headerlink" title="说说你对栈和堆的理解？"></a>说说你对栈和堆的理解？</h1><p>  栈：系统自动分配的，速度快，空间小，<br>  堆：是人为开辟的，速度慢，空间大</p>
<h1 id="如何使用js给一个按钮绑定多个事件？"><a href="#如何使用js给一个按钮绑定多个事件？" class="headerlink" title="如何使用js给一个按钮绑定多个事件？"></a>如何使用js给一个按钮绑定多个事件？</h1><p>  用事件监听 addEventListener绑定两个事件</p>
<h1 id="怎么判断一个变量是不是object"><a href="#怎么判断一个变量是不是object" class="headerlink" title="怎么判断一个变量是不是object"></a>怎么判断一个变量是不是object</h1><p>  object.prototype.toString.call</p>
<h1 id="let-var-const的区别"><a href="#let-var-const的区别" class="headerlink" title="let var const的区别"></a>let var const的区别</h1><p>  let：是块作用域，可以重复复制，没有变量提升<br>  const：是块作用域，只能赋值一次，没有变量提升<br>  var：受代码块影响，有变量提升</p>
<h1 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for in 和 for of的区别"></a>for in 和 for of的区别</h1><p>  for in：遍历对象<br>  for of：不能遍历对象</p>
<h1 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别"></a>undefined和null的区别</h1><p>  undefined：未定义，表示现在没有，以后会有，转换为数值为0<br>  null：空，表示现在没有之后也不会有，转换为数值为NaN</p>
<h1 id="如何判断undefined和null"><a href="#如何判断undefined和null" class="headerlink" title="如何判断undefined和null"></a>如何判断undefined和null</h1><p>  用typeof方法：undefined&#x3D;&#x3D;undefined  null&#x3D;&#x3D;object</p>
<h1 id="说出Array常用的方法，并且说明方法的作用"><a href="#说出Array常用的方法，并且说明方法的作用" class="headerlink" title="说出Array常用的方法，并且说明方法的作用"></a>说出Array常用的方法，并且说明方法的作用</h1><p>  push：尾部添加<br>  unshift：头部添加<br>  shift：头部删除<br>  pop：尾部删除<br>  filter：过滤<br>  reverse：反转<br>  join：将数组转为字符串<br>  concat：拼接<br>  sort：排序</p>
<h1 id="如何实现深浅拷贝"><a href="#如何实现深浅拷贝" class="headerlink" title="如何实现深浅拷贝"></a>如何实现深浅拷贝</h1><p>  浅拷贝：一个对象拷贝另一个对象的引用地址，更在一个对象另一个对象也会跟着影响<br>  深拷贝：一个对象拷贝另一个对象的引用，更改一个对象另一个对象不受影响</p>
<h1 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="2.转换方法"></a>2.转换方法</h1><pre><code>Number()
强制转换为数字 其他方法还有：在前加+ 、减-、乘*、除/
规则：能转换成数字的优先转成数字，实在转不出来就转成NaN
Boolean()  转换布尔 显示转换 隐式转换  转换的规则：非空非0即为真
toString() 转换字符串 并不是用来转成字符串的，而是用来检测数据类型的 null和undefined不能用toString()转
isNaN() 判断是不是非数字 判断规则：判断之前先用Number()方法做隐式转换
判断规则：null只和undefined和它本身相等 其余的null、undefined不和任何值相等 判断之前有一个Number()方法的隐式转换
</code></pre>
<h1 id="3-对象解构赋值和数组解构赋值"><a href="#3-对象解构赋值和数组解构赋值" class="headerlink" title="3.对象解构赋值和数组解构赋值"></a>3.对象解构赋值和数组解构赋值</h1><pre><code>对象展开运算符
let obj = &#123;
hello: &#39;hello&#39;,
world: &#39;world&#39;,
name: &#39;Tim&#39;,
age: 18
&#125;
let &#123;hello, world, ...hi&#125; = obj;
数组使用扩展运算符解构
function f () &#123;
return [&#39;hello&#39;, &#39;world&#39;, &#39;my&#39;, &#39;name&#39;, &#39;is Lilei&#39;];
&#125;
let [hello, world, ...who] = f()
</code></pre>
<h1 id="4-js-获取-dom-的方法"><a href="#4-js-获取-dom-的方法" class="headerlink" title="4.js 获取 dom 的方法"></a>4.js 获取 dom 的方法</h1><pre><code>通过 ID 获取（getElementById）
通过 name 属性（getElementsByName）
通过标签名（getElementsByTagName）
通过类名（getElementsByClassName）
获取 html 的方法（document.documentElement）
获取 body 的方法（document.body）
通过 css 选择器获取一个元素（document.querySelector）
通过选择器获取一组元素（document.querySelectorAll）
</code></pre>
<h1 id="5-获取和设置元素属性的方法"><a href="#5-获取和设置元素属性的方法" class="headerlink" title="5.获取和设置元素属性的方法"></a>5.获取和设置元素属性的方法</h1><pre><code>元素.setAttribute(&#39;属性名&#39;,属性值) 设置元素的行间属性，如果原来有这个行间属性会覆盖原来的行间属性
元素.getAttribute(&#39;属性名&#39;) 获取元素的行间属性对应的属性值，不能获取 css 样式对应的属性值 如果获
取的属性不存在返回 null
getComputedStyle 获取经过浏览器计算后的属性 获取的结果是带单位的字符串
</code></pre>
<h1 id="6-js-dom-元素方法"><a href="#6-js-dom-元素方法" class="headerlink" title="6.js dom 元素方法"></a>6.js dom 元素方法</h1><pre><code>1. 如何在 dom 元素前面添加元素（内部添加）
dom.insertBefore(newDom,dom.firstChild)
2. 如何在 dom 元素前面添加元素（外部添加）
dom.parentNode.inserBefore(newDom,dom)
3. 如何在 dom 元素后面添加元素(外部添加)
dom.parentNode.insertBefore(newDom,dom.nextSibling)
4. dom.appendChild(dom 元素)，元素尾部添加新元素（内部添加）
js 有哪些动态添加 dom 元素的方法？
-  parent.appendChild(newDom,existDom) 在 existDom 的前面添加新元素，parent 为 existDom 的父元素
js 有哪些删除元素的方法
1. dom.remove();自身调用 remove 删除
2. parent.removeChild(child) 父元素删除子元素
</code></pre>
<h1 id="7-js-如何判断一个变量时-null-undefined"><a href="#7-js-如何判断一个变量时-null-undefined" class="headerlink" title="7.js 如何判断一个变量时 null&#x2F;undefined"></a>7.js 如何判断一个变量时 null&#x2F;undefined</h1><pre><code>用==null 来判断是否为 undefined 或 null 值
因为!null 为真，所以也可以简单的把判断语句改为！null 写法来同时判断 undefined 或 null 值
</code></pre>
<h1 id="8-js-判断是否为对象"><a href="#8-js-判断是否为对象" class="headerlink" title="8.js 判断是否为对象"></a>8.js 判断是否为对象</h1><pre><code>typeof:  主要用来检查基本数据类型
instanceof: 用于检测构造函数中的原型(prototype)属性是否出现在某个实例对象的原型链上
constructor: 用于检测实例对象是否是由某个构造函数实例化出来的
object.prototype.toString().call():检测对象的时候不用加call，别的数据类型必须用call，否则的话就变成
了转成字符串的方法了
</code></pre>
<h1 id="9-new-关键字做了哪些事情？"><a href="#9-new-关键字做了哪些事情？" class="headerlink" title="9.new 关键字做了哪些事情？"></a>9.new 关键字做了哪些事情？</h1><pre><code>1.在堆内存中申请一块空间，创建一个新对象&#123;&#125;
2.新对象的__proto__指向构造函数中的原型对象prototype
3.确认this指向让上下文中this指向这个新对象
4.执行构造函数中的代码 初始化新对象
5.返回新对象 返回的是新对象的地址值 即便没有return 构造函数也会默认返回this
</code></pre>
<h1 id="10-字符串反转方式"><a href="#10-字符串反转方式" class="headerlink" title="10.字符串反转方式"></a>10.字符串反转方式</h1><pre><code>let newStr = str.split(&quot;&quot;).reverse().join(&quot;&quot;);
</code></pre>
<h1 id="11-jquery-的“-”有什么作用-可以把-换成其他的吗？"><a href="#11-jquery-的“-”有什么作用-可以把-换成其他的吗？" class="headerlink" title="11.jquery 的“$”有什么作用?可以把$换成其他的吗？"></a>11.jquery 的“$”有什么作用?可以把$换成其他的吗？</h1><pre><code>$是JQuery常用的一个回传函数，定义为 “选取”，英文是 selector 的缩写
</code></pre>
<p>$其实是 jQuery 的别称，而 jQuery 就是 jQuery 库提供的一个函数。<br>    该函数可以根据 () 里的参数进行查找和选择 html 文档中的元素，()内不仅可以是 ID，还可以是各类选择器<br>    可以替换，var jquery$ &#x3D; jQuery.noConflict();</p>
<h1 id="12-tcp-和-udp-区别"><a href="#12-tcp-和-udp-区别" class="headerlink" title="12.tcp 和 udp 区别"></a>12.tcp 和 udp 区别</h1><pre><code>他俩是什么？
    是运输层的两种协议：
        运输层就是负责向两台主机之间进行通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文
TCP 是面向连接的，UDP 是无连接的
TCP 是可靠的，UDP 是不可靠的
TCP 是面向字节流的，UDP 是面向数据报文的
TCP 只支持点对点通信，UDP 支持一对一，一对多，多对多
TCP 报文首部 20 个字节，UDP 首部 8 个字节
TCP 有拥塞控制机制，UDP 没有
TCP 协议下双方发送接受缓冲区都有，UDP 并无实际意义上的发送缓冲区，但是存在接受缓冲区
</code></pre>
<h1 id="13-ajax请求的五个步骤，"><a href="#13-ajax请求的五个步骤，" class="headerlink" title="13.ajax请求的五个步骤，"></a>13.ajax请求的五个步骤，</h1><p>创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。</p>
<h1 id="14-浏览器渲染过程"><a href="#14-浏览器渲染过程" class="headerlink" title="14.浏览器渲染过程"></a>14.浏览器渲染过程</h1><pre><code>将获取的 html 解析成 dom 树
处理 css，构成层叠样式表模型 CSSOM（是对CSS样式表的对象化表示，同时还提供了相关API用来操作CSS样式）
将 dom 树和 CSSOM 合并为渲染树
根据 CSSOM 将渲染树的节点布局计算
将渲染树节点样式绘制到页面上
</code></pre>
<h1 id="15-浅拷贝与深拷贝"><a href="#15-浅拷贝与深拷贝" class="headerlink" title="15.浅拷贝与深拷贝"></a>15.浅拷贝与深拷贝</h1><pre><code>浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用 
方法：- Object.assign(目标对象，源对象)
    - var obj1=&#123;&#125;
        for(var key in obj)&#123;
        obj1[key]=obj[key]
        &#125;
    - obj1=&#123;...obj&#125;;
    - concat
深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”
方式：- 使用jq中的$.extend
    - 用JSON.parse(JSON.stringify(你要复制的对象))
    - 递归
</code></pre>
<h1 id="16-统计字符串中每个字母出现的次数"><a href="#16-统计字符串中每个字母出现的次数" class="headerlink" title="16. 统计字符串中每个字母出现的次数"></a>16. 统计字符串中每个字母出现的次数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj=&#123;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">var</span> key =str[i]<br>    <span class="hljs-keyword">if</span>(obj[key])&#123;<br>        obj[key]++<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        obj[key]=<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key i obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key+<span class="hljs-string">&#x27;出现了&#x27;</span>+obj[key])<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="17-什么是-IIFE"><a href="#17-什么是-IIFE" class="headerlink" title="17. 什么是 IIFE"></a>17. 什么是 IIFE</h1><pre><code>立即执行函数表达式：IIFE（Immediately-invoked function expression）
总结 IFEE 的优点： 1.创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发
中全局变量和函数的命名冲突；
2.IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指
向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；
</code></pre>
<h1 id="18-如何改变this指向"><a href="#18-如何改变this指向" class="headerlink" title="18.如何改变this指向"></a>18.如何改变this指向</h1><pre><code>是函数的方法
call 传参只能传值 可以直接调用
apply 传参只能传数组 可以直接调用 应用场景：找出数组的最大值/最小值
bind 只能传值 默认不能直接调用 应用场景：事件或者计时器里边修改this指向 
</code></pre>
<h1 id="19-如何阻止事件冒泡和默认事件"><a href="#19-如何阻止事件冒泡和默认事件" class="headerlink" title="19.如何阻止事件冒泡和默认事件"></a>19.如何阻止事件冒泡和默认事件</h1><pre><code>event.stopPropagation()：阻止事件的冒泡方法
event.preventDefault()：阻止默认事件的方法
return false：就等于同时调用了 event.stopPropagation()和 event.preventDefault()
</code></pre>
<h1 id="20-JavaScript-三大对象：本地对象、内置对象、宿主对象"><a href="#20-JavaScript-三大对象：本地对象、内置对象、宿主对象" class="headerlink" title="20.JavaScript 三大对象：本地对象、内置对象、宿主对象"></a>20.JavaScript 三大对象：本地对象、内置对象、宿主对象</h1><pre><code>a.本地对象
与宿主无关，无论在浏览器还是服务器中都有的对象，就是 ECMAScript 标准中定义的类(构造函数)
在使用过程中需要我们手动 new 创建
例如：Boolean、Number、String、Array、Function、Object、Date、RegExp 等
b.内置对象
与宿主无关，无论在浏览器还是服务器中都有的对象
ECMAScript 已经帮我们创建好的对象
在使用过程中无需我们动手 new 创建
例如：Global、Math、JSON
c.宿主对象
什么是宿主？
宿主就是指 JavaScript 运行环境，js 可以在浏览器中运行，也可以在服务器上运行(nodejs)
对于嵌入到网页中的 js 来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象
包含：Window 和 Docuument 等
所有的 DOM 和 BOM 对象都属于宿主对象
</code></pre>
<h1 id="21-数组扁平化-数组拉平"><a href="#21-数组扁平化-数组拉平" class="headerlink" title="21.数组扁平化&#x2F;数组拉平"></a>21.数组扁平化&#x2F;数组拉平</h1><pre><code>- 用 ECMAscript 2019 中的 arr.flat(Infinity) 方法
- 利用 arr.toString(），将数组转换为字符串
再利用 str.split（‘ ，’），将字符串转换为新的数组
map遍历，parseInt（）每一项转数组
- 使用 ES6 新增的扩展运算符
- 递归
</code></pre>
<h1 id="22-map-filter-for-in-的区别"><a href="#22-map-filter-for-in-的区别" class="headerlink" title="22.map,filter,for in 的区别"></a>22.map,filter,for in 的区别</h1><pre><code>map 则可以改变当前循环的值，返回一个新的被改变过值之后的数组（map 需 return）
filter 函数可以看成是一个过滤函数，返回符合条件的元素的数组
for…in 循环数组索引、对象的属性，但使用 for…in 原型链上的所有属性都将被访问，用 hasOwnProperty() 方法
解决。map 方法有返回值，可以 return 出来
</code></pre>
<h1 id="23-js-中实例方法和原型方法的区别"><a href="#23-js-中实例方法和原型方法的区别" class="headerlink" title="23.js 中实例方法和原型方法的区别"></a>23.js 中实例方法和原型方法的区别</h1><pre><code>实例方法就是只有实例可以调用，静态方法只有构造函数可以调用，原型方法是实例和构造函数都可以调用，是共享
的方法
像Promise.all和Promise.race这些就是静态方法，Promise.prototype.then这些就是原型方法，new 出来的实
例可以调用
</code></pre>
<h1 id="24-节流和防抖的区别"><a href="#24-节流和防抖的区别" class="headerlink" title="24.节流和防抖的区别"></a>24.节流和防抖的区别</h1><pre><code>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于
设置的时间，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用一次函数。
</code></pre>
<h1 id="25-浏览器内核"><a href="#25-浏览器内核" class="headerlink" title="25.浏览器内核"></a>25.浏览器内核</h1><pre><code>  浏览器内核又可以分成两部分：渲染引擎和JS引擎
  渲染引擎：负责获取网页的内容并显示，不同的浏览器内核对网页的解析渲染也不同
  JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果
  常用内核(内核种类很多)
      常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit
</code></pre>
<h1 id="26-实现浏览器内多个标签页面之间通信"><a href="#26-实现浏览器内多个标签页面之间通信" class="headerlink" title="26.实现浏览器内多个标签页面之间通信"></a>26.实现浏览器内多个标签页面之间通信</h1><pre><code>一、cookie + setInterval 方式
二、localStorage 方式
三、webSocket 方式
</code></pre>
<h1 id="27-jQuery-对象与-DOM-对象的相互转化"><a href="#27-jQuery-对象与-DOM-对象的相互转化" class="headerlink" title="27.jQuery 对象与 DOM 对象的相互转化"></a>27.jQuery 对象与 DOM 对象的相互转化</h1><p>jq转dom<br>    - 利用数组下标的方式读取 jQuery 中的 DOM 对象 var div &#x3D; $div[0]<br>    - jQuery对象自身提供一个.get()方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供了一个元素<br>    的索引var div &#x3D; $div.get(0)<br>dom转jq<br>    对象加工成一个 jQuery 对象。$(参数)是一个对功能大方法，通过传递不同的参数而产生不同的作用，<br>    var div &#x3D; $(div)</p>
<h1 id="28-jQuery-获取的-dom-对象和原生的-dom-对象有何区别？"><a href="#28-jQuery-获取的-dom-对象和原生的-dom-对象有何区别？" class="headerlink" title="28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？"></a>28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？</h1><pre><code>js 原生获取的 dom 是一个对象，jQuery 对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他
们两者是不同的对象类型不等价。
</code></pre>
<h1 id="29-Jq-如何扩展自定义方法"><a href="#29-Jq-如何扩展自定义方法" class="headerlink" title="29.Jq 如何扩展自定义方法"></a>29.Jq 如何扩展自定义方法</h1><pre><code>\$.extend(&#123;
　　 a:function ()&#123;
　　　　 alert(&#39;I&#39; m lc&#39;);
　　&#125;
&#125;)
</code></pre>
<h1 id="30-jq-给所有元素加虚线"><a href="#30-jq-给所有元素加虚线" class="headerlink" title="30.jq 给所有元素加虚线"></a>30.jq 给所有元素加虚线</h1><pre><code>\$(&quot;\*&quot;).css(&quot;border:2px dotted/dashed #000;&quot;)
</code></pre>
<h1 id="31-关于-jquery-的-load-方法"><a href="#31-关于-jquery-的-load-方法" class="headerlink" title="31.关于 jquery 的 load()方法"></a>31.关于 jquery 的 load()方法</h1><pre><code>jquery load 方法是对 jQuery.ajax()进行封装以方便我们使用的一个方法，当我们需要处理较为复杂的逻辑时候，
还是需要用到 jQuery.ajax()这个比较全面的方法的。
load()主要用来加载 header、footer、siderbar、tip(提示框/输入框)等多个公共组件，以及简单的调用动态接口。
完整语法格式：load( url, [data], [callback] )
参数:
url 是指要导入文件的地址。
data： 可选参数；因为 load 不仅仅可以导入静态的 html 文件，还可以导入动态脚本，例如 PHP 文件，所以要导
入的是动态文件时，
我们可以把要传递的参数放在这里。
callback：可选参数；是指调用 load 方法并得到服务器响应后，再执行的另外一个函数；回调参数：response, 
status, xhr
</code></pre>
<h2 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a>$.ajax 方法</h2><p>url 表示请求的地址<br>type 表示请求的类型 GET 或 POST 请求<br>data 表示发送给服务器的数据格式有两种： 一：name&#x3D;value&amp;name&#x3D;value 二：{key:value}<br>success 请求成功，响应的回调函数</p>
<h1 id="32-document-ready-和-window-onload-的区别"><a href="#32-document-ready-和-window-onload-的区别" class="headerlink" title="32.document.ready 和 window.onload 的区别"></a>32.document.ready 和 window.onload 的区别</h1><pre><code>页面加载完成有两种事件，一是 ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是 onload，
指示页面包含图片等文件在内的所有元素都加载完成。
ready先加载，onload页面加载完之后加载
</code></pre>
<h1 id="33-瀑布流实现的原理"><a href="#33-瀑布流实现的原理" class="headerlink" title="33.瀑布流实现的原理"></a>33.瀑布流实现的原理</h1><pre><code>瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。
创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为 0）
然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。
</code></pre>
<h1 id="34-lazyload-的实现原理"><a href="#34-lazyload-的实现原理" class="headerlink" title="34.lazyload 的实现原理"></a>34.lazyload 的实现原理</h1><pre><code>图片可视 iscando 为 false，获取页面滚动高度，再判断图片是否在用户可视范围之内，如果在的话，将图片
的 iscando 设为 true，声明一个 src 地址合集，当可视范围为 true 时，将 src 赋值给图片的 src 属性
加载条件
img.offsetTop &lt; window.innerHeight + document.body.scrollTop;
var imgs = document.querySelectorAll(&#39;img&#39;);
window.onscroll = function()&#123;
var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
var winTop = window.innerHeight;
for(var i=0;i &lt; imgs.length;i++)&#123;
if(imgs[i].offsetTop &lt; scrollTop + winTop )&#123;
imgs[i].src = imgs[i].getAttribute(&#39;data-src&#39;);
&#125;
&#125;
&#125;
实现性能提高需要将节流和懒加载一起使用
</code></pre>
<h1 id="35-Array-与-ArrayBuffer-的区别"><a href="#35-Array-与-ArrayBuffer-的区别" class="headerlink" title="35.Array 与 ArrayBuffer 的区别"></a>35.Array 与 ArrayBuffer 的区别</h1><pre><code>ArrayBuffer 只能定义长度，无法直接读取它的内容
每个 ArrayBuffer 对象表示的只是内存中指定的字节数;
但不会指定这些字节用于保存什么类型的数据；
通过 ArrayBuffer 能做的，就是为了将来使用而分配一定数量的字节.
</code></pre>
<h1 id="36-js-在浏览器兼容有那些问题"><a href="#36-js-在浏览器兼容有那些问题" class="headerlink" title="36.js 在浏览器兼容有那些问题"></a>36.js 在浏览器兼容有那些问题</h1><pre><code>HTML 对象获取问题
FireFox：document.getElementById(“idName”);
ie:document.idname 或者 document.getElementById(“idName”).
自定义属性问题
IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性
；Firefox 下，只能使用 getAttribute() 获取自定义属性。
解决方法：统一通过 getAttribute() 获取自定义属性。
</code></pre>
<h1 id="37-document-write-和-innerHTML-的区别"><a href="#37-document-write-和-innerHTML-的区别" class="headerlink" title="37.document.write()和 innerHTML 的区别"></a>37.document.write()和 innerHTML 的区别</h1><pre><code>document.write 是重写整个 document, 写入内容是字符串的 html，会导致页面全部重绘
innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容，不会导致页面全部重绘
</code></pre>
<h1 id="38-JavaScript-中的作用域、作用域链"><a href="#38-JavaScript-中的作用域、作用域链" class="headerlink" title="38.JavaScript 中的作用域、作用域链"></a>38.JavaScript 中的作用域、作用域链</h1><pre><code>作用域的本质是一个保存变量的对象，作用域避免了不同范围内的数据的相互干扰。
变量的作用域无非就是两种：全局变量和局部变量。
全局作用域：
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：
局部作用域：
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见
的例如函数内部
作用域链是由多级作用域串联形成的链式结构
根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。将会按照作用
域链一级级向上寻找搜索
延长作用域链就是在作用域链的前端增加一个变量对象。“with语句”
</code></pre>
<h1 id="39-为什么异步加载-js-，加载方式"><a href="#39-为什么异步加载-js-，加载方式" class="headerlink" title="39.为什么异步加载 js ，加载方式"></a>39.为什么异步加载 js ，加载方式</h1><pre><code>异步加载是立即下载 js 脚本的同时又不妨碍页面中的其他操作。
defer：规定是否对脚本执行进行延迟，但却是并行下载，要等到 DOM 文档全部加载解析好了，才会被执行。
只有 IE 能用，也可以将代码写到内部
&lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;

async：异步加载，加载好了就执行，不管页面是否解析好。async 只能加载外部脚本，不能把 js 写在 script
标签里(IE9 以上都能执行，比较普遍)
动态创建 script 标签插入到 dom 元素中
</code></pre>
<h1 id="40-js-面向对象的继承方法"><a href="#40-js-面向对象的继承方法" class="headerlink" title="40.js 面向对象的继承方法"></a>40.js 面向对象的继承方法</h1><pre><code>1、通过改变原型的指向实现继承
2、借用父级构造函数实例继承(通过call修改this指向)
3、组合继承
原型继承，混合继承
</code></pre>
<h1 id="41-重绘和重排"><a href="#41-重绘和重排" class="headerlink" title="41.重绘和重排"></a>41.重绘和重排</h1><pre><code>重绘是一个元素外观的改变导致的浏览器行为（例如改变 visibility，outline，background 等属性），浏
览器会根据元素新的属性呈现新的外观；
重排是 DOM 元素被 js 触发某种变化，渲染树需要重新计算。浏览器对 DOM 树进行重新排列；这便是重排。
排列完成之后重新绘制元素则是重绘。
</code></pre>
<h1 id="42-js-去除空格"><a href="#42-js-去除空格" class="headerlink" title="42.js 去除空格"></a>42.js 去除空格</h1><pre><code>str.replace(/\s+/g,&quot;&quot;);
</code></pre>
<h1 id="43-使用-es5-语法，如何将一个类似数组的对象转换为数组？（比如-document-getElementsByTagName-…-的返回值）"><a href="#43-使用-es5-语法，如何将一个类似数组的对象转换为数组？（比如-document-getElementsByTagName-…-的返回值）" class="headerlink" title="43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）"></a>43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）</h1><pre><code>Array.prototype.slice.call(document.getElementsByTagName(...))
</code></pre>
<h1 id="44-js-如何判读一个对象是否为空对象"><a href="#44-js-如何判读一个对象是否为空对象" class="headerlink" title="44.js 如何判读一个对象是否为空对象"></a>44.js 如何判读一个对象是否为空对象</h1><pre><code>for in 遍历这个对象，如果有值的话，就不是空，否则就是空
  var obj = &#123;&#125;;
  var b = function() &#123;
  for(var key in obj) &#123;
  return false;
  &#125;
  return true;
  &#125;
  将对象转化为 json 字符串，再判断该字符串是否为&quot;&#123;&#125;&quot;
  var data = &#123;&#125;;
  var b = (JSON.stringify(data) == &quot;&#123;&#125;&quot;);
  alert(b);
</code></pre>
<h1 id="45-dom-元素上的-property-和-attribute-的区别"><a href="#45-dom-元素上的-property-和-attribute-的区别" class="headerlink" title="45.dom 元素上的 property 和 attribute 的区别"></a>45.dom 元素上的 property 和 attribute 的区别</h1><pre><code>  对属性 Property 可以赋任何类型的值，而对特性 Attribute 只能赋值字符串！
  对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的
  但是对于自定义的属性来说，他们是不同步的.(自定义属性不会自动添加到 property)
  1.property 能够从 attribute 中得到同步；
  2.attribute 不会同步 property 上的值；
</code></pre>
<h1 id="46-js-控制循环的方法"><a href="#46-js-控制循环的方法" class="headerlink" title="46.js 控制循环的方法"></a>46.js 控制循环的方法</h1><pre><code>  break
  终止循环
  跳出本层循环，继续执行循环后面的语句。
  如果循环有多层，则 break 只能跳出一层
  continue
  跳过本次循环剩余的代码，继续执行下一次循环。
</code></pre>
<h1 id="47-斐波那契"><a href="#47-斐波那契" class="headerlink" title="47.斐波那契"></a>47.斐波那契</h1><pre><code>  function Fibonacci(n)&#123;
  if(n == 1 || n == 2)&#123;
  return 1;
  &#125;
  else&#123;
  return Fibonacci(n - 1) + Fibonacci(n - 2);
  &#125;
  &#125;
</code></pre>
<h1 id="48-事件冒泡"><a href="#48-事件冒泡" class="headerlink" title="48.事件冒泡"></a>48.事件冒泡</h1><pre><code>  事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级
  的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，
  这些函数都会被一次触发。
  事件冒泡有下到上，事件捕获有上到下
</code></pre>
<h1 id="49-JavaScript-的同源策略"><a href="#49-JavaScript-的同源策略" class="headerlink" title="49.JavaScript 的同源策略"></a>49.JavaScript 的同源策略</h1><pre><code>  同源：协议、域名、端口全部相同才是同源，考虑到安全性，不同源之间不能够进行数据通信
</code></pre>
<h1 id="50-url组成"><a href="#50-url组成" class="headerlink" title="50.url组成"></a>50.url组成</h1><pre><code>http:/https: 协议
www.baidu.com 域名
:8080 端口
/sf/vsearch 路径
?wd=百度热搜 查询(可有可无)
#a=1&amp;b=2 哈希值(可有可无)
</code></pre>
<h1 id="51-for-in-和-for-of-循环的区别"><a href="#51-for-in-和-for-of-循环的区别" class="headerlink" title="51.for in 和 for of 循环的区别 ?"></a>51.for in 和 for of 循环的区别 ?</h1><pre><code>`for in` 用于遍历对象的键(`key`)，`for in`会遍历所有自身的和原型链上的可枚举属性。如果是数组，
</code></pre>
<p>for in会将数组的索引(index)当做对象的key来遍历，其他的object也是一样的。<br>    <code>for of</code>是<code>es6</code>引入的语法，用于遍历 所有迭代器iterator，其中包括<br><code>HTMLCollection</code>,<code>NodeList</code>,<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>TypedArray</code>，<code>arguments</code>等<br>对象的值(<code>item</code>)</p>
<h1 id="52-url请求过程"><a href="#52-url请求过程" class="headerlink" title="52.url请求过程"></a>52.url请求过程</h1><pre><code>    DNS 解析:将域名地址解析成 IP 地址
    TCP 连接：TCP 三次握手
    处理请求：发送请求
    接收响应：响应报文
    渲染页面：浏
    断开连接：四次挥手
</code></pre>
<h1 id="53-10-50的随机数"><a href="#53-10-50的随机数" class="headerlink" title="53.10-50的随机数"></a>53.10-50的随机数</h1><pre><code>- Math.floor(Math.random()*39)+10
- Math.ceil(Math.random()*40)+10
</code></pre>
<h1 id="54-获取时间"><a href="#54-获取时间" class="headerlink" title="54.获取时间"></a>54.获取时间</h1><pre><code>var date = new Date();
    var year = date.getFullYear();    //  返回的是年份
    var month = date.getMonth() + 1;  //  返回的月份上个月的月份，记得+1才是当月
    var dates = date.getDate();       //  返回的是几号
    var day = date.getDay();          //  周一返回的是1，周六是6，但是周日是0
</code></pre>
<h1 id="55-性能优化"><a href="#55-性能优化" class="headerlink" title="55.性能优化"></a>55.性能优化</h1><pre><code>减少请求数量、使用缓存、减少资源大小、精灵图
</code></pre>
<h1 id="56-eval-的作用"><a href="#56-eval-的作用" class="headerlink" title="56.eval()的作用"></a>56.eval()的作用</h1><p>eval()可以接受一个字符串str作为参数，并把这个参数作为脚本代码来执行。<br>    eval(string) 函数计算 JavaScript 字符串，并把它作为脚本代码来执行<br>    如果参数是一个表达式，eval() 函数将执行表达式；<br>    如果参数是Javascript语句，eval()将执行 Javascript 语句；<br>    如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。<br>    特殊：eval(“{b:2}”) &#x2F;&#x2F; 声明一个对象<br>    eval(“（{b:2}）”) &#x2F;&#x2F; 返回对象{b:2}</p>
<h2 id="Function和eval有什么区别？"><a href="#Function和eval有什么区别？" class="headerlink" title="Function和eval有什么区别？"></a>Function和eval有什么区别？</h2><p>共同点：都可以将字符串转化为js代码<br>不同点：Function创建出来的函数并不会直接调用，只有当手动去调用创建出来的函数的时候才调用，eval把字符串<br>转化为代码后，直接就执行了。</p>
<h1 id="57-本地存储"><a href="#57-本地存储" class="headerlink" title="57.本地存储"></a>57.本地存储</h1><pre><code>- localStorage、sessionStorage、cookie三者的区别
存储大小
    cookie数据大小不能超过4k ；
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；
有效时间
    localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
    sessionStorage 数据在当前浏览器窗口关闭后自动删除；
    cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；
数据与服务器之间的交互方式
    cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存；
</code></pre>
<h1 id="58-会话cookie-持久cookie"><a href="#58-会话cookie-持久cookie" class="headerlink" title="58.会话cookie 持久cookie"></a>58.会话cookie 持久cookie</h1><pre><code>- 如果 cookie 不包含到期日期，则可视为会话 cookie
    - 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。
- 如果 cookie 包含到期日期，则可视为持久性 cookie。
    -  在指定的到期日期，cookie 将从磁盘中删除。
</code></pre>
<h1 id="59-cookie替代"><a href="#59-cookie替代" class="headerlink" title="59.cookie替代"></a>59.cookie替代</h1><pre><code>localStorage、sessionStorage
</code></pre>
<h1 id="60-if有作用域吗"><a href="#60-if有作用域吗" class="headerlink" title="60.if有作用域吗"></a>60.if有作用域吗</h1><pre><code>只有函数有作用域，if是没有作用域的。
但是有一种情况会让if看上去有作用域，就是在if &#123;&#125;语句中，使用const、let，他们会有块级作用域。
</code></pre>
<h1 id="61-promise"><a href="#61-promise" class="headerlink" title="61.promise"></a>61.promise</h1><pre><code>- promise是解决异步的方法
    - Promise对象有两个特点：
        - 1）对象的状态不受外界的影响。
        - 2）状态一旦改变，便不会再次改变。而且它的状态改变只会由
        （pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。
- Promise的优点：
    - 支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱
        - 什么是回调地狱？
            - 多个回调函数层层嵌套，外层回调函数异步返回的结果是内层回调函数执行的条件
        - 回调地狱的缺点？
            - 1、可读性、可维护性差
            - 不便于异常处理
        - 什么是回调函数？
            - 函数被当做参数被传给另外一个函数
</code></pre>
<h1 id="62-async-await"><a href="#62-async-await" class="headerlink" title="62.async&#x2F;await"></a>62.async&#x2F;await</h1><pre><code>async用来修饰function，async返回promise，await写在async里面，await后面是promise
在async函数中await的作用是把promise作为同步执行
</code></pre>
<h1 id="63-什么是闭包？"><a href="#63-什么是闭包？" class="headerlink" title="63.什么是闭包？"></a>63.什么是闭包？</h1><ol>
<li>内层函数可有访问外层函数和变量</li>
<li>内层函数对外层函数的活动变量进行访问</li>
<li>内层函数执行、创建上下文，此时就形成了闭包 &#x3D;》 闭包就是一个环境<br> 一句话概括：<br> 或者说：闭包就是可以访问其他函数内部数据的函数<br> 或者说：当一个嵌套的内部（子）函数引用了嵌套外部（父）函数的变量（函数时）内部（子）函数执行就<br> 产生了闭包<ul>
<li><p>闭包的好处：延长作用域链、缓存数据、避免全局污染<br>  闭包应用：<br>      让函数外部可以操作函数内部的数据、定义S模块<br>      具有特定功能的js文件，将所有的数据和功能都封装在一个函数内部（私有的）<br>      只向外部暴露一个包含n个方法的对象或函数<br>      模块的使用者，只需要通过没看暴露的对象调用</p>
</li>
<li><p>闭包的缺点：<br>      容易造成内存泄漏<br>      常见的js内存泄漏陷阱：闭包、遗漏的定时器、定义过多的全局变量</p>
</li>
<li><p>什么叫内存溢出：<br>      指程序申请内存时，没有足够的内存提供申请者使用，导致数据无法正常存储到内存中</p>
</li>
<li><p>什么叫内存泄漏：<br>      是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其<br>      他进程使用。<br>      通常少次数的内存无法及时回收并且不会得到程序造成什么影响，但是如果在内存本身就比较少<br>      获取多次导致内存<br>      无法正常回收时，就会导致内存不够用，最终导致内存溢出。</p>
</li>
</ul>
</li>
</ol>
<h1 id="64-webpack-的-bundle，chunk，module-的意思"><a href="#64-webpack-的-bundle，chunk，module-的意思" class="headerlink" title="64.webpack 的 bundle，chunk，module 的意思"></a>64.webpack 的 bundle，chunk，module 的意思</h1><pre><code>module 是 webpack 支持解析的模块；
chunk 包含多个 module，存在于 webpack 处理过程中的阶段；
bundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；
</code></pre>
<h1 id="65-webpack性能优化"><a href="#65-webpack性能优化" class="headerlink" title="65.webpack性能优化"></a>65.webpack性能优化</h1><pre><code>打包公共代码
动态导入和按需加载
删除无用的代码
长缓存优化
公共代码内联
</code></pre>
<h1 id="66-webpack-的-bundle，chunk，module-的意思"><a href="#66-webpack-的-bundle，chunk，module-的意思" class="headerlink" title="66.webpack 的 bundle，chunk，module 的意思"></a>66.webpack 的 bundle，chunk，module 的意思</h1><pre><code>module 是 webpack 支持解析的模块；
chunk 包含多个 module，存在于 webpack 处理过程中的阶段；
bundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；
</code></pre>
<h1 id="67-lazyload的实现原理"><a href="#67-lazyload的实现原理" class="headerlink" title="67.lazyload的实现原理"></a>67.lazyload的实现原理</h1><p>将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）<br>属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。<br>注：图片要指定宽高<br><img  src="default.jpg" data- class="lazyload" data-original="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  /><br>当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。<br>这样便实现了懒加载。</p>
<h1 id="68-this指向"><a href="#68-this指向" class="headerlink" title="68.this指向"></a>68.this指向</h1><pre><code>- 对象中的this指向当前对象
- 默认情况下指向window
- 自执行函数中this指向window
- 计时器中this指向window
- 事件中的this指向事件源
- 箭头函数中的this指向上一层的范围
- 构造函数中的this指向构造函数实例
</code></pre>
<h1 id="69-什么是原型链？"><a href="#69-什么是原型链？" class="headerlink" title="69.什么是原型链？"></a>69.什么是原型链？</h1><pre><code>访问属性时，从对象自身沿着__proto__指向，一直到Object.prototype,形成一个链式结构(访问属性时就近原则)
</code></pre>
<h1 id="70-原型对象"><a href="#70-原型对象" class="headerlink" title="70.原型对象"></a>70.原型对象</h1><pre><code>只要声明函数，系统自动产生一个对象，就叫原型对象
存放所有实例对象需要数据共享(属性或者方法)节省了内存空间 避免了全局污染 
</code></pre>
<h1 id="71-为什么写在原型上的方法或者属性，实例对象会自动继承？"><a href="#71-为什么写在原型上的方法或者属性，实例对象会自动继承？" class="headerlink" title="71.为什么写在原型上的方法或者属性，实例对象会自动继承？"></a>71.为什么写在原型上的方法或者属性，实例对象会自动继承？</h1><pre><code>所有的对象都有一个属性__proto__
因为：原型对象的constructor和实例对象中constructor指向同一个
</code></pre>
<h1 id="72-实例是如何访问到constructor属性的"><a href="#72-实例是如何访问到constructor属性的" class="headerlink" title="72.实例是如何访问到constructor属性的"></a>72.实例是如何访问到constructor属性的</h1><pre><code>实例通过proto访问到构造函数原型，构造函数原型的constructor=构造函数
</code></pre>
<h1 id="73-原型对象-、实例对象-、-构造函数三者之间的关系"><a href="#73-原型对象-、实例对象-、-构造函数三者之间的关系" class="headerlink" title="73.原型对象 、实例对象 、 构造函数三者之间的关系"></a>73.原型对象 、实例对象 、 构造函数三者之间的关系</h1><pre><code>1、实例对象是有构造函数实例化出来的
2、构造函数中有一个prototype属性 指向的是prototy原型对象
    在原型对象上有一个constructor属性 他指向是构造器 该构造器表示的是原型所在的构造函数
3、实例对象中有一个__proto__属性，指向的是实例对象的构造函数中的prototype原型对象
</code></pre>
<h1 id="74-普通函数和构造函数有哪些区别？"><a href="#74-普通函数和构造函数有哪些区别？" class="headerlink" title="74.普通函数和构造函数有哪些区别？"></a>74.普通函数和构造函数有哪些区别？</h1><pre><code>构造函数用new fn()    普通函数fn()
this指向实例	this指向window
默认返回实例，return引用类型生效，return基本类型无效
普通函数默认返回undefined，return生效
</code></pre>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><h1 id="1-ajax请求的五个步骤，"><a href="#1-ajax请求的五个步骤，" class="headerlink" title="1. ajax请求的五个步骤，"></a>1. ajax请求的五个步骤，</h1><h2 id="创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。-流程：-2-ajax同步和异步的区别-同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。-3-ajax-获取数据-请求方式：-get：获取数据-post：向服务器推送数据-put：给服务器上增加资源（上传图片）-delete-删除资源-向服务器传输内容方式与get一致-head：获取服务器的响应头信息-向服务器传输内容方式与get一致-传参方式-get：直接拼接路径后面-url-name-lis-age-20-psot：传参必须要写请求头-目的：为了传递解析好的数据-设置完在传递-1-xhr-setRequestHeader-‘Content-Type’-”application-x-www-form-urlencoded”-xhr-send-“name-lis-age-20”-2-xhr-setRequestHeader-‘Content-Type’-”application-json”-xhr-send-“-name-aa-age-111-”-4-有封装过-axios-吗？怎么封装的？-axios-是一个轻量的-HTTP-客户端-基于-XMLHttpRequest-服务来执行-HTTP-请求，支持丰富的配置，支持-Promise，支持浏览器端和-Node-js-端-axios-的请求是使用-Promise-来实现-XMLHttpRequset-的，promise-本身就是一个异步的处理的方案，-所以-axios-是异步的"><a href="#创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。-流程：-2-ajax同步和异步的区别-同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。-3-ajax-获取数据-请求方式：-get：获取数据-post：向服务器推送数据-put：给服务器上增加资源（上传图片）-delete-删除资源-向服务器传输内容方式与get一致-head：获取服务器的响应头信息-向服务器传输内容方式与get一致-传参方式-get：直接拼接路径后面-url-name-lis-age-20-psot：传参必须要写请求头-目的：为了传递解析好的数据-设置完在传递-1-xhr-setRequestHeader-‘Content-Type’-”application-x-www-form-urlencoded”-xhr-send-“name-lis-age-20”-2-xhr-setRequestHeader-‘Content-Type’-”application-json”-xhr-send-“-name-aa-age-111-”-4-有封装过-axios-吗？怎么封装的？-axios-是一个轻量的-HTTP-客户端-基于-XMLHttpRequest-服务来执行-HTTP-请求，支持丰富的配置，支持-Promise，支持浏览器端和-Node-js-端-axios-的请求是使用-Promise-来实现-XMLHttpRequset-的，promise-本身就是一个异步的处理的方案，-所以-axios-是异步的" class="headerlink" title="创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。## 流程：# 2.ajax同步和异步的区别    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。# 3.ajax 获取数据    请求方式：        get：获取数据        post：向服务器推送数据        put：给服务器上增加资源（上传图片）        delete: 删除资源,向服务器传输内容方式与get一致        head：获取服务器的响应头信息,向服务器传输内容方式与get一致    传参方式        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)                  xhr.send(“{name:aa,age:111}”)# 4.有封装过 axios 吗？怎么封装的？     axios 是一个轻量的 HTTP 客户端    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，    所以 axios 是异步的"></a>创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。<br>## 流程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">创建xhr<br><span class="hljs-keyword">var</span> xhr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHTTPRequest</span>()<br>侦听通信状态改变的事件<br>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;readystatechange&quot;</span>,    readyStateChangeHandler);<br><span class="hljs-title class_">Method</span> 分为 get post put <span class="hljs-keyword">delete</span>等等<br><span class="hljs-title class_">Async</span> 异步同步<br>name和password是用户名和密码<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-title class_">Method</span>,<span class="hljs-variable constant_">URL</span>,<span class="hljs-title class_">Async</span>,name,password)<br>发送内容给服务器<br>xhr.<span class="hljs-title function_">send</span>(内容)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readyStateChangeHandler</span>(<span class="hljs-params">e</span>)&#123;<br>当状态是<span class="hljs-number">4</span>时，并且响应头成功<span class="hljs-number">200</span>时，<br><span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span>===<span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span>===<span class="hljs-number">200</span>)&#123;<br>打印返回的消息<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">response</span>)<br></code></pre></td></tr></table></figure><br># 2.ajax同步和异步的区别<br>    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就<br>处于一个阻塞的状态。<br>异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某<br>些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全<br>请求返回就可以开始后面的代码运行。<br># 3.ajax 获取数据<br>    请求方式：<br>        get：获取数据<br>        post：向服务器推送数据<br>        put：给服务器上增加资源（上传图片）<br>        delete: 删除资源,向服务器传输内容方式与get一致<br>        head：获取服务器的响应头信息,向服务器传输内容方式与get一致<br>    传参方式<br>        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20<br>        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递<br>              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)<br>                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)<br>              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)<br>                  xhr.send(“{name:aa,age:111}”)<br># 4.有封装过 axios 吗？怎么封装的？<br>     axios 是一个轻量的 HTTP 客户端<br>    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端<br>    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，<br>    所以 axios 是异步的</h2><pre><code>封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间…
设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分
请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
状态码: 根据接口返回的不同 status ， 来执行不同的业务，这块需要和后端约定好
请求方法：根据 get、post 等方法进行一个再次封装，使用起来更为方便
请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问
响应拦截器：这块就是根据 后端`返回来的状态码判定执行不同业务
</code></pre>
<h1 id="5-ajax状态码"><a href="#5-ajax状态码" class="headerlink" title="5.ajax状态码"></a>5.ajax状态码</h1><pre><code>0. 请求未初始化
1. 发起请求建立连接
2. 接受请求
3. 解析服务器
4. 请求成功
</code></pre>
<h1 id="6-什么是跨域？"><a href="#6-什么是跨域？" class="headerlink" title="6.什么是跨域？"></a>6.什么是跨域？</h1><pre><code>   所谓跨域 不是请求未发送 而是请求发起成功 服务器接收成功、并且服务器将数据响应给了浏览器 浏览器
   对数据做了拦截
</code></pre>
<p>   为什么会产生跨域？<br>       项目发布的时候不同的功能发布在不同的服务器上<br>       同源策略： 协议、域名、端口不一致就跨域</p>
<h1 id="7-如何解决跨域"><a href="#7-如何解决跨域" class="headerlink" title="7.如何解决跨域"></a>7.如何解决跨域</h1><pre><code>（1）后端设置请求头 res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)
       或者设置白名单 
           let whiteList = [&#39;http://127.0.0.1:5500&#39;]
           if(whiteList.includes(req.headers.origin))&#123;
             res.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin)
           &#125;
（2）后端用插件 
    const cors = require(&#39;cors&#39;)  app.use(cors())
（3）用json的原理
    JSONP 是一种非正式传输协议，可以通过动态创建script标签的形式，把script标签的src属性，指向
    数据接口的地址，因为script标签不存在跨域限制，
   - 当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用
   后台页面中的一个callback函数。然后服务端返回数据时会将这个callback 参数作为函数名来包裹住
    JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
</code></pre>
<h1 id="8-状态码"><a href="#8-状态码" class="headerlink" title="8.状态码"></a>8.状态码</h1><pre><code>        1**：请求收到，继续处理
        2**：操作成功收到，分析、接受
        3**：完成此请求必须进一步处理
        4**：请求包含一个错误语法或不能完成
        5**：服务器执行一个完全有效请求失败

        100——客户必须继续发出请求
        101——客户要求服务器根据请求转换HTTP协议版本

        200——交易成功
        201——提示知道新文件的URL
        202——接受和处理、但处理未完成
        203——返回信息不确定或不完整
        204——请求收到，但返回信息为空
        205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
        206——服务器已经完成了部分用户的GET请求


        300——请求的资源可在多处得到
        301——删除请求数据
        302——在其他地址发现了请求数据
        303——建议客户访问其他URL或访问方式
        304——客户端已经执行了GET，但文件未变化
        305——请求的资源必须从服务器指定的地址得到
        306——前一版本HTTP中使用的代码，现行版本中不再使用
        307——申明请求的资源临时性删除


        400——错误请求，如语法错误
        401——请求授权失败
        402——保留有效ChargeTo头响应
        403——请求不允许
        404——没有发现文件、查询或URl
        405——用户在Request-Line字段定义的方法不允许
        406——根据用户发送的Accept拖，请求资源不可访问
        407——类似401，用户必须首先在代理服务器上得到授权
        408——客户端没有在用户指定的饿时间内完成请求
        409——对当前资源状态，请求不能完成
        410——服务器上不再有此资源且无进一步的参考地址
        411——服务器拒绝用户定义的Content-Length属性请求
        412——一个或多个请求头字段在当前请求中错误
        413——请求的资源大于服务器允许的大小
        414——请求的资源URL长于服务器允许的长度
        415——请求资源不支持请求项目格式
        416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含
        If-Range请求头字段
        417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器
        不能满足请求

        
        500——服务器产生内部错误
        501——服务器不支持请求的函数
        502——服务器暂时不可用，有时是为了防止发生系统过载
        503——服务器过载或暂停维修
        504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
        505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>John Doe</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2023/11/02/JS/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2023&#x2F;11&#x2F;02&#x2F;JS&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2023&#x2F;11&#x2F;02&#x2F;JS&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
  <nav class="nav">
    <a href="/2023/11/02/vue/"><i class="iconfont iconleft"></i>前端面试题   VUE篇</a>
    <a href="/2023/11/01/CSS/">前端面试题   CSS篇<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8js%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E4%B8%BA%E5%87%A0%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E9%82%A3%E6%9C%89%E4%BA%9B%EF%BC%9F"><span class="toc-text">在js中，数据类型分为几类？它们的数据类型分别那有些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">说说你对栈和堆的理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8js%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-text">如何使用js给一个按钮绑定多个事件？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AFobject"><span class="toc-text">怎么判断一个变量是不是object</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let-var-const%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">let var const的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">for in 和 for of的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">undefined和null的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADundefined%E5%92%8Cnull"><span class="toc-text">如何判断undefined和null</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E5%87%BAArray%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%B4%E6%98%8E%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">说出Array常用的方法，并且说明方法的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">如何实现深浅拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-text">2.转换方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">3.对象解构赋值和数组解构赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-js-%E8%8E%B7%E5%8F%96-dom-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4.js 获取 dom 的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.获取和设置元素属性的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-js-dom-%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-text">6.js dom 元素方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-js-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6-null-undefined"><span class="toc-text">7.js 如何判断一个变量时 null&#x2F;undefined</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-js-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.js 判断是否为对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-new-%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-text">9.new 关键字做了哪些事情？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-text">10.字符串反转方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-jquery-%E7%9A%84%E2%80%9C-%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E5%8F%AF%E4%BB%A5%E6%8A%8A-%E6%8D%A2%E6%88%90%E5%85%B6%E4%BB%96%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">11.jquery 的“$”有什么作用?可以把$换成其他的吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-tcp-%E5%92%8C-udp-%E5%8C%BA%E5%88%AB"><span class="toc-text">12.tcp 和 udp 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C"><span class="toc-text">13.ajax请求的五个步骤，</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">14.浏览器渲染过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">15.浅拷贝与深拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">16. 统计字符串中每个字母出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AF-IIFE"><span class="toc-text">17. 什么是 IIFE</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91"><span class="toc-text">18.如何改变this指向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">19.如何阻止事件冒泡和默认事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-JavaScript-%E4%B8%89%E5%A4%A7%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">20.JavaScript 三大对象：本地对象、内置对象、宿主对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96-%E6%95%B0%E7%BB%84%E6%8B%89%E5%B9%B3"><span class="toc-text">21.数组扁平化&#x2F;数组拉平</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-map-filter-for-in-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">22.map,filter,for in 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-js-%E4%B8%AD%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">23.js 中实例方法和原型方法的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">24.节流和防抖的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-text">25.浏览器内核</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">26.实现浏览器内多个标签页面之间通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-jQuery-%E5%AF%B9%E8%B1%A1%E4%B8%8E-DOM-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-text">27.jQuery 对象与 DOM 对象的相互转化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-jQuery-%E8%8E%B7%E5%8F%96%E7%9A%84-dom-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E7%94%9F%E7%9A%84-dom-%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-Jq-%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-text">29.Jq 如何扩展自定义方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-jq-%E7%BB%99%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8A%A0%E8%99%9A%E7%BA%BF"><span class="toc-text">30.jq 给所有元素加虚线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E5%85%B3%E4%BA%8E-jquery-%E7%9A%84-load-%E6%96%B9%E6%B3%95"><span class="toc-text">31.关于 jquery 的 load()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-%E6%96%B9%E6%B3%95"><span class="toc-text">$.ajax 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-document-ready-%E5%92%8C-window-onload-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">32.document.ready 和 window.onload 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E7%80%91%E5%B8%83%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">33.瀑布流实现的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-lazyload-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">34.lazyload 的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-Array-%E4%B8%8E-ArrayBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">35.Array 与 ArrayBuffer 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-js-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%9C%89%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">36.js 在浏览器兼容有那些问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-document-write-%E5%92%8C-innerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">37.document.write()和 innerHTML 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-JavaScript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">38.JavaScript 中的作用域、作用域链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js-%EF%BC%8C%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-text">39.为什么异步加载 js ，加载方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-js-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-text">40.js 面向对象的继承方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92"><span class="toc-text">41.重绘和重排</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-js-%E5%8E%BB%E9%99%A4%E7%A9%BA%E6%A0%BC"><span class="toc-text">42.js 去除空格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E4%BD%BF%E7%94%A8-es5-%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84%EF%BC%9F%EF%BC%88%E6%AF%94%E5%A6%82-document-getElementsByTagName-%E2%80%A6-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%89"><span class="toc-text">43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-js-%E5%A6%82%E4%BD%95%E5%88%A4%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">44.js 如何判读一个对象是否为空对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-dom-%E5%85%83%E7%B4%A0%E4%B8%8A%E7%9A%84-property-%E5%92%8C-attribute-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">45.dom 元素上的 property 和 attribute 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-js-%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">46.js 控制循环的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="toc-text">47.斐波那契</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">48.事件冒泡</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-JavaScript-%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">49.JavaScript 的同源策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-url%E7%BB%84%E6%88%90"><span class="toc-text">50.url组成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-for-in-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">51.for in 和 for of 循环的区别 ?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">52.url请求过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-10-50%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">53.10-50的随机数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-text">54.获取时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">55.性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-eval-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">56.eval()的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Function%E5%92%8Ceval%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Function和eval有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">57.本地存储</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-%E4%BC%9A%E8%AF%9Dcookie-%E6%8C%81%E4%B9%85cookie"><span class="toc-text">58.会话cookie 持久cookie</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-cookie%E6%9B%BF%E4%BB%A3"><span class="toc-text">59.cookie替代</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60-if%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%90%97"><span class="toc-text">60.if有作用域吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-promise"><span class="toc-text">61.promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-async-await"><span class="toc-text">62.async&#x2F;await</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-text">63.什么是闭包？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64-webpack-%E7%9A%84-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-text">64.webpack 的 bundle，chunk，module 的意思</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65-webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">65.webpack性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-webpack-%E7%9A%84-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-text">66.webpack 的 bundle，chunk，module 的意思</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-lazyload%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">67.lazyload的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68-this%E6%8C%87%E5%90%91"><span class="toc-text">68.this指向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="toc-text">69.什么是原型链？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">70.原型对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%9C%A8%E5%8E%9F%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">71.为什么写在原型上的方法或者属性，实例对象会自动继承？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#72-%E5%AE%9E%E4%BE%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%88%B0constructor%E5%B1%9E%E6%80%A7%E7%9A%84"><span class="toc-text">72.实例是如何访问到constructor属性的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-%E3%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1-%E3%80%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">73.原型对象 、实例对象 、 构造函数三者之间的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#74-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">74.普通函数和构造函数有哪些区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C"><span class="toc-text">1. ajax请求的五个步骤，</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8send%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%9B%91%E5%90%AC%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%8C%E6%8E%A5%E6%94%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82-%E6%B5%81%E7%A8%8B%EF%BC%9A-2-ajax%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%90%8C%E6%AD%A5%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A5%BD%E6%AF%94%E5%9C%A8%E6%8E%92%E9%98%9F%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%A8%E7%9D%80%E4%B8%80%E4%B8%AA%E7%9A%84%E5%8E%BB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%89%8D%E9%9D%A2%E7%9A%84%E6%B2%A1%E6%9C%89%E7%BB%93%E6%9D%9F%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%A4%84%E4%BA%8E%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%E8%AF%AD%E5%8F%A5%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%8C%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%9F%90%E4%BA%9B%E6%84%BF%E6%84%8F%EF%BC%8C%E9%9C%80%E8%A6%81%E6%85%A2%E6%85%A2%E7%9A%84%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%B8%A6%E5%AE%BD%E6%98%AF%E5%BE%88%E7%A9%BA%E9%97%B2%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%8D%E4%BC%9A%E7%AD%89%E5%88%B0%E5%89%8D%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%8C%E5%85%A8%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E3%80%82-3-ajax-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9A-get%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-post%EF%BC%9A%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE-put%EF%BC%9A%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%A2%9E%E5%8A%A0%E8%B5%84%E6%BA%90%EF%BC%88%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%89-delete-%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90-%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%A0%E8%BE%93%E5%86%85%E5%AE%B9%E6%96%B9%E5%BC%8F%E4%B8%8Eget%E4%B8%80%E8%87%B4-head%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF-%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%A0%E8%BE%93%E5%86%85%E5%AE%B9%E6%96%B9%E5%BC%8F%E4%B8%8Eget%E4%B8%80%E8%87%B4-%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F-get%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8B%BC%E6%8E%A5%E8%B7%AF%E5%BE%84%E5%90%8E%E9%9D%A2-url-name-lis-age-20-psot%EF%BC%9A%E4%BC%A0%E5%8F%82%E5%BF%85%E9%A1%BB%E8%A6%81%E5%86%99%E8%AF%B7%E6%B1%82%E5%A4%B4-%E7%9B%AE%E7%9A%84%EF%BC%9A%E4%B8%BA%E4%BA%86%E4%BC%A0%E9%80%92%E8%A7%A3%E6%9E%90%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE-%E8%AE%BE%E7%BD%AE%E5%AE%8C%E5%9C%A8%E4%BC%A0%E9%80%92-1-xhr-setRequestHeader-%E2%80%98Content-Type%E2%80%99-%E2%80%9Dapplication-x-www-form-urlencoded%E2%80%9D-xhr-send-%E2%80%9Cname-lis-age-20%E2%80%9D-2-xhr-setRequestHeader-%E2%80%98Content-Type%E2%80%99-%E2%80%9Dapplication-json%E2%80%9D-xhr-send-%E2%80%9C-name-aa-age-111-%E2%80%9D-4-%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87-axios-%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E7%9A%84%EF%BC%9F-axios-%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%9A%84-HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%9F%BA%E4%BA%8E-XMLHttpRequest-%E6%9C%8D%E5%8A%A1%E6%9D%A5%E6%89%A7%E8%A1%8C-HTTP-%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%94%AF%E6%8C%81%E4%B8%B0%E5%AF%8C%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E6%94%AF%E6%8C%81-Promise%EF%BC%8C%E6%94%AF%E6%8C%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%92%8C-Node-js-%E7%AB%AF-axios-%E7%9A%84%E8%AF%B7%E6%B1%82%E6%98%AF%E4%BD%BF%E7%94%A8-Promise-%E6%9D%A5%E5%AE%9E%E7%8E%B0-XMLHttpRequset-%E7%9A%84%EF%BC%8Cpromise-%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C-%E6%89%80%E4%BB%A5-axios-%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。## 流程：123456789101112131415创建xhrvar xhr&#x3D;new XMLHTTPRequest()侦听通信状态改变的事件xhr.addEventListener(&quot;readystatechange&quot;,    readyStateChangeHandler);Method 分为 get post put delete等等Async 异步同步name和password是用户名和密码xhr.open(Method,URL,Async,name,password)发送内容给服务器xhr.send(内容)function readyStateChangeHandler(e){当状态是4时，并且响应头成功200时，if(xhr.readyState&#x3D;&#x3D;&#x3D;4 &amp;&amp; xhr.status&#x3D;&#x3D;&#x3D;200){打印返回的消息console.log(xhr.response)# 2.ajax同步和异步的区别    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。# 3.ajax 获取数据    请求方式：        get：获取数据        post：向服务器推送数据        put：给服务器上增加资源（上传图片）        delete: 删除资源,向服务器传输内容方式与get一致        head：获取服务器的响应头信息,向服务器传输内容方式与get一致    传参方式        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)                  xhr.send(“{name:aa,age:111}”)# 4.有封装过 axios 吗？怎么封装的？     axios 是一个轻量的 HTTP 客户端    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，    所以 axios 是异步的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-ajax%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">5.ajax状态码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">6.什么是跨域？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-text">7.如何解决跨域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">8.状态码</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=3068206598 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="https://github.com/little-zhi "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:3068206598@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="">azhi</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>